# nachos-nucleus-message-passing
Implemented nucleus message passing in nachos 


## Objective 
The multiprogramming system that we have allows the dynamic creation of a hierarchy of processes in which diverse strategies of program scheduling and resource allocation can be implemented. 

But for the designer of advanced information systems, any operating system should allow him to change the mode of operation it controls, and this is a vital requirement. If it is not provided his freedom of design will be limited seriously. Unfortunately, none of the present operating system allows it. Most of the present operating system works on single mode of operation, such as batch processing, priority scheduling, real time scheduling, or conversational access. 

The user of the operating system more often finds it hopeless to modify an operating system that has made rigid assumptions in its basic design about a specific mode of operation. 

This unfortunate situation indicates that the main problem in the design of a multiprogramming system is not to define functions that satisfy specific operating needs, but rather to supply a system nucleus that can be extended with new operating systems in an orderly manner. This is the primary objective.

In a system of parallel, cooperating processes, mechanisms must be provided for the synchronization of two processes during a transfer of information. Dijkstra has demonstrated that indivisible lock and unlock operations operating on binary semaphores are sufficient primitives from a logical point of view. 

Instead we have introduced message buffering within the system nucleus as the basic means of process communication. The system nucleus administers a common pool of message buffers and a message queue for each process.

The following four system calls as described in the papers, to be called by user programs 
*	SendMessage (asynchronous system call)
*	WaitMessage (synchronous system call)
*	SendAnswer (asynchronous system call)
*	WaitAnswer (synchronous system call)

### Solution from the paper
The system nucleus simulates an environment in which program execution and input/output are handled uniformly as parallel, cooperating processes. The purpose of the system nucleus is to implement these fundamental concepts: simulation of processes, communication among processes, creation, control, and removal of processes. 

In the paper, a basic means of communication within the process communication has been introduces as message buffering within the system nucleus. Each process has a common pool of message buffers and message queue which is being administrated by the system nucleus. 

Following primitives are available for communication between internal processes:
*	send message (receiver, message, buffer)
Copy the message into the first available buffer in the pool of buffers and delivers it into the queue of the receiver. The receiver is activated if waiting for the message. The sender continues after being informed of the identity of the message buffer. 

*	wait message (sender, message, buffer)
Delay requesting the process until a message arrives in the process’s queue. In return it is supplied with identity of the sender, message and identity of the message buffer. The buffer is removed from the queue and made ready to transmit the answer. 

*	send answer (result, answer, buffer)
Copies the answer in which the message has been received and is delivered to the queue of the sender. The answering process continues to process, and the sender is activated if it was waiting for an answer. 

*	wait answer (result, answer, buffer)
Delays the requesting process until answer arrives in the given buffer. Upon arrival the answer is copied, and the buffer is returned into the pool of buffers. Dummy message will be generated by the system nucleus in case of non-existing receiver. 
 
### Advantages and Disadvantages of the solution discussed 
#### Advantages
*	Wait message makes it possible for the process to be unaware of the existence of other processes until a message is received from that process. Which is same as in the case of a multiprogramming system which has processes appear and disappear at any time. 
*	When a communication has been established between two processes, the selection of buffer can be regarded as creation of unique identification for the communication. Thus, multiple messages can be exchanged between them.
*	The system nucleus has to make sure that no other process can interfere with the conversation with other two processes. This is done by storing the sender and receiver information in each buffer and comparing it when a process attempts to send or wait for an answer in a given buffer. 
*	Efficiency is obtained by queuing of buffers, which enables a sending process to continue immediately after delivery of a message or an answer.
*	The system is dynamic. The process can be removed at any time and the reverse situation is also possible. 
#### Disadvantages
*	It introduces yet another resource problem. Since the availability of buffers in the pool is limited, if the process sends messages to ignorant processes which does not responds for a long time, further communication with other processes will be blocked due to unavailability of buffers. To mitigate this problem, a limit is put on number of messages a process can send simultaneously. 

## What has been implemented 

### kernel.h 
*	To maintain a pool of buffers in kernel we used a bitmap
*	To maintain a list of messages for each thread we used a map between thread name and list of messages
*	List of buffers is used to keep track of the bufferIDs that has been used for the communication
*	List of messages called as removedMessages is used to keep track of the messages that has been received by a process but will not send any answer 

### message.h

*	A message class to maintain sender of the message, receiver of the message, bufferId through which the message will be passed through the threads and the contents of the message.

### messageBuf.h

*	Messagebuffer class to maintain sender of the message, receiver of the message, bufferId assigned for message passing and a list of messages to keep track of the messages that pass through this bufferId

### To make multiprogramming possible:
*	In /nachos/code/threads/main.cc a vector is used to hold the user programs that will be passed with -x flag
*	We fork a thread for each user program and call RunUserProg program

### To implement system calls:
*	Under /nachos/code/userprog/syscall.h SC_SendMessage,  SC_WaitMessage, SC_SendAnswer, SC_WaitAnswer system calls along with their codes have been added
*	/nachos/code/test/start.S file has been modified with the new system calls

### exception.cc
#### SC_sendMessage
* We read 3 arguments passed: destination, message, bufferId
*	We construct a msg object with the sender name, receiver name, buffer id and the message contents
*	We first check If bufferId passed is -1 if so then it is the first message being sent.
*	Now we check for any available buffer from the buffer pool.
*	if a buffer is available then
*	We append the message into the buffer's list of messages.
*	We append the buffer into the list of buffers.
*	Now we check if the receiver already exists in the map.
*	If so, then We append the message into the receiver's list of messages.
* Else, we create a new message list for the receiver.
*	We append the message into the receiver's list of messages.
*	And create a new entry into the map 
*	if there is no available buffer in the buffer pool we drop the message and call finish()

if the bufferId passed is not equal to -1, then it is not the first message being sent

*	find the bufferId from the list of buffers
*	We then append the message into the buffer's list of messages
*	We append the message into the receiver's list of messages
*	write the bufferId into reg 2 so that a wait answer can be called using the same bufferId
*	We then increment the PC

####	SC_waitMessage

*	We read 2 arguments passed: source of the message say P1 and destination of the message say P2.
*	we find for P2's entry in the map based on the current threads name.
*	Now we get P2's message list from the map.
*	we iterate through the message list to find a message which has the same sender name and the receiver name as that of the arguments passed.
*	append the message to the removedMessages list.
*	remove the message from the message list.
*	write the bufferId into reg2.
*	Call yield
*	Increment PC

####	SC_sendAnswer 

*	Read 4 arguments passed: source, destination, bufferId and answer
*	We iterate through the list of buffers.
*	We find the bufferId through which message was received
*	We append the ans to list of messages.
*	Now we find the receiver's (of the answer) list of messages in the map and append the ans.
*	if the receiver is not present in the map then we create a new message list and append the ans to it.
*	We iterate through the list of removed messages to find the message which has the same sender name as that of the answer's receiver name and has the message's receiver name as that of the answer's sender's name inorder to remove such a message from the list.
*	yield the current thread.
*	increment PC

####	SC_waitAnswer

* Read 3 argumnets passed: source of the answer, destination of the answer and the bufferId which is same as that of the bufferId used to sendMessage
*	iterate through the list of buffers.
*	find the buffer whose bufferId is same as that of the bufferId passed as an argument.
*	iterate though that buffer's list of messages.
*	In that list of messages find the message whose sender name and receiver name are same as that of the arguments passed.
*	Now remove that message from the receiver's list of messages.
*	Also remove the message from the buffer's list of messages
*	yield the current thread
*	Increment PC

####	SC_Exit

*	iterate through the list of removedMessages
*	find a message whose receiver name is same as that of the currentThread’s name
*	send a dummy Answer as exit has been called without SendAnswer.
*	iterate through the list of buffers
*	find the bufferId that is same as that of the message's bufferId.
*	append dummy ans to the buffer's list of messages
*	find the receiver's list of messages and append the dummy ans
*	if there is no receiver found in map then create a new list of messages and append dummy ans.
*	iterate through the list of buffers.
*	find the buffer whose sender name is same as that of the current thread’s name.
*	mark the buffer as available in the pool of buffers.
*	append the bufferId into the list of bufferIds.
*	iterate through the list of bufferIds and remove the buffers from the list of buffers
*	call finish on the currentThread



### functions used:
*	parseInput function takes the pointer of a string and returns the string
*	removeBuffers method is used to remove the buffer from the kernel's list of buffers, once communication is done or when a process that initiated the communication exits

##	How to test your solution 
* If you’re adding any new user programs to the /nachos/code/test/ folder run make clean; make; command in the test folder. 
* If not, navigate to /nachos/code/build.linux/ and run make clean; make depend; make; command.
* And to run user programs run the following commands
* ./nachos -x ../test/progA -x ../test/progB
